<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tambola Game - Play</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@latest/dist/full.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif; display: flex; flex-direction: column;
            min-height: 100vh; padding-top: 70px; padding-bottom: 100px;
        }
        .flex-grow { flex-grow: 1; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        .drawer-side > *:not(label) { overflow-y: auto; }

        .ticket-grid {
            display: grid; grid-template-columns: repeat(9, 1fr); gap: 2px;
            border: 1px solid oklch(var(--bc)); border-radius: 0.5rem; padding: 0.25rem;
            background-color: oklch(var(--b2)); margin-bottom: 1rem; max-width: 500px; margin-left: auto; margin-right: auto;
        }
        .ticket-cell {
            display: flex; align-items: center; justify-content: center;
            aspect-ratio: 1 / 1; min-height: 35px; border: 1px solid oklch(var(--b3));
            border-radius: 0.25rem; font-weight: bold; cursor: pointer;
            transition: background-color 0.3s, color 0.3s, transform 0.2s;
            background-color: oklch(var(--b1));
        }
        .ticket-cell.empty { background-color: oklch(var(--b2)); cursor: default; }
        .ticket-cell.marked {
            background-color: oklch(var(--p)); color: oklch(var(--pc));
            transform: scale(1.05); box-shadow: 0 0 8px oklch(var(--p));
        }
        .ticket-cell.marked-boogie { background-color: oklch(var(--er)); color: oklch(var(--ec)); animation: shake 0.5s; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); } 75% { transform: translateX(-5px); }
        }
        .called-numbers-bar {
            display: flex; overflow-x: auto; padding: 0.5rem; gap: 0.5rem;
            background-color: oklch(var(--b2)); border-radius: 0.5rem; margin-bottom: 1rem;
        }
        .called-number-badge { flex-shrink: 0; }
        .top-nav-player { position: fixed; top: 0; left: 0; right: 0; z-index: 50; }
        .bottom-nav-player-controls {
            position: fixed; bottom: 0; left: 0; right: 0;
            background-color: oklch(var(--b1)); padding: 0.75rem; box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            z-index: 45; display: flex; flex-wrap: wrap; gap: 0.5rem;
            align-items: center; justify-content: space-around;
        }
        .game-message-popup {
            position: fixed;
            top: 80px; /* Below navbar */
            right: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 0.375rem; /* rounded-md */
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-size: 0.875rem; /* text-sm */
            z-index: 1000; /* High z-index */
            max-width: 300px;
            word-wrap: break-word;
        }
    </style>
</head>
<body x-data="playerGame()">
    <div class="drawer lg:drawer-open">
        <input id="player-drawer" type="checkbox" class="drawer-toggle" x-model="isDrawerOpen" />
        <div class="drawer-content flex flex-col bg-base-200">
            <nav class="navbar bg-base-100 shadow-lg top-nav-player">
                <div class="flex-none">
                    <label for="player-drawer" class="btn btn-square btn-ghost lg:hidden" aria-label="Open menu">
                        <i class="fas fa-bars text-xl"></i>
                    </label>
                </div>
                <div class="flex-1">
                    <div class="avatar placeholder mr-2 ml-2">
                        <div class="bg-neutral-focus text-neutral-content rounded-full w-10 h-10">
                            <span class="text-xl" x-text="playerName ? playerName.charAt(0).toUpperCase() : 'P'"></span>
                        </div>
                    </div>
                    <a class="btn btn-ghost normal-case text-lg sm:text-xl">Welcome, <span x-text="playerName || 'Player'"></span>!</a>
                </div>
                <div class="flex-none">
                    <div class="dropdown dropdown-end ml-2">
                        <label tabindex="0" class="btn btn-ghost btn-circle indicator">
                            <i class="fas fa-bell text-xl"></i>
                            <template x-if="notifications.length > 0">
                                <span class="indicator-item badge badge-primary badge-sm" x-text="notifications.length"></span>
                            </template>
                        </label>
                        <ul tabindex="0" class="menu menu-sm dropdown-content mt-3 z-[50] p-2 shadow bg-base-100 rounded-box w-64 sm:w-80 max-h-96 overflow-y-auto">
                            <template x-if="notifications.length === 0">
                                <li class="p-2 text-center text-sm text-base-content/70">No new notifications</li>
                            </template>
                            <template x-for="notification in notifications" :key="notification.id">
                                <li>
                                    <a @click="handleNotificationClick(notification)" class="whitespace-normal text-xs p-2 hover:bg-base-200">
                                        <div class="flex flex-col w-full">
                                            <div class="font-semibold" x-text="notification.type"></div>
                                            <div class="text-base-content/80" x-text="notification.message"></div>
                                            <div class="text-xs opacity-60 mt-1 self-end" x-text="new Date(notification.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })"></div>
                                        </div>
                                    </a>
                                </li>
                            </template>
                             <template x-if="notifications.length > 0">
                                <div class="divider my-1"></div>
                                <li><a @click="clearAllNotifications()" class="text-xs text-center text-error p-2 hover:bg-error hover:text-error-content">Clear All</a></li>
                            </template>
                        </ul>
                    </div>
                    <div class="dropdown dropdown-end">
                        <label tabindex="0" class="btn btn-ghost btn-circle" aria-label="Theme selector">
                            <i class="fas fa-palette"></i>
                        </label>
                        <ul tabindex="0" class="menu menu-sm dropdown-content mt-3 z-[50] p-2 shadow bg-base-100 rounded-box w-52">
                            <template x-for="theme in themes" :key="theme">
                                <li><a @click="setTheme(theme, $event)" x-text="theme.charAt(0).toUpperCase() + theme.slice(1)"></a></li>
                            </template>
                        </ul>
                    </div>
                    <button @click="logout" class="btn btn-ghost btn-circle" aria-label="Logout">
                        <i class="fas fa-sign-out-alt text-xl"></i>
                    </button>
                </div>
            </nav>

            <main class="flex-grow p-4 overflow-y-auto">
                <div x-show="currentView === 'home'" x-transition>
                    <div class="mb-6">
                        <h3 class="text-xl font-semibold mb-1 text-center">Room: <span x-text="roomId" class="font-mono"></span></h3>
                        <div class="text-center mb-1">Admin: <span x-text="adminName || 'N/A'"></span></div>
                        <div class="text-center mb-3">Status: <span class="badge badge-lg"
                            :class="{
                                'badge-neutral': gameStatus === 'idle' || gameStatus === 'connecting' || gameStatus === 'disconnected' || gameStatus === 'loading',
                                'badge-success': gameStatus === 'running',
                                'badge-warning': gameStatus === 'paused',
                                'badge-error': gameStatus === 'stopped' || gameStatus === 'error'
                            }"
                            x-text="gameStatus"></span>
                        </div>

                        <div class="flex items-center justify-center mb-3">
                            <span class="mr-2">Latest:</span>
                            <span class="badge badge-accent badge-lg p-4 text-2xl" x-text="latestCalledNumber || '---'"></span>
                        </div>
                        <div class="called-numbers-bar">
                            <template x-if="calledNumbersHistory.length === 0">
                                <span class="italic text-base-content/70">No numbers called yet.</span>
                            </template>
                            <template x-for="num in calledNumbersHistory.slice().reverse()" :key="num">
                                <span class="badge badge-neutral called-number-badge" x-text="num"></span>
                            </template>
                        </div>
                    </div>

                    <div class="space-y-6">
                        <template x-if="tickets.length === 0 && gameStatus === 'running'">
                            <div class="text-center p-6 bg-base-100 rounded-lg shadow">
                                <p class="text-lg">You don't have any tickets for this game yet!</p>
                                <button @click="requestNewTicket" class="btn btn-primary mt-4" :disabled="waitingForTicketApproval || tickets.length >= 5">
                                    Request a Ticket <span x-show="waitingForTicketApproval">(Pending...)</span>
                                </button>
                            </div>
                        </template>
                         <template x-if="tickets.length === 0 && (gameStatus !== 'running')">
                             <div class="text-center p-6 bg-base-100 rounded-lg shadow">
                                <p class="text-lg" x-text="gameStatusMessage"></p>
                             </div>
                         </template>
                        <template x-for="(ticket, ticketIndex) in tickets" :key="ticket.id">
                            <div class="card bg-base-100 shadow-xl">
                                <div class="card-body p-2 sm:p-4">
                                    <h4 class="card-title text-sm sm:text-base justify-center mb-2">Ticket <span x-text="ticketIndex + 1"></span> <span class="text-xs">(ID: <span x-text="ticket.id ? ticket.id.substring(0,6) : 'N/A'"></span>)</span></h4>
                                    <div class="ticket-grid">
                                        <template x-for="(row, rowIndex) in ticket.numbers" :key="rowIndex">
                                            <template x-for="(cell, cellIndex) in row" :key="cellIndex">
                                                <div class="ticket-cell"
                                                     :class="{
                                                         'empty': cell === null,
                                                         'marked': ticket.marked && ticket.marked.includes(cell) && cell !== null,
                                                         'marked-boogie': tempBoogieCells.includes(ticket.id + '-' + cell)
                                                     }"
                                                     @click="manualMarkNumber(ticket.id, cell)"
                                                     x-text="cell !== null ? cell : ''">
                                                </div>
                                            </template>
                                        </template>
                                    </div>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>

                <div x-show="currentView === 'players'" x-transition> /* ... as before ... */ </div>
                <div x-show="currentView === 'rules'" x-transition> /* ... as before ... */ </div>
                <div x-show="currentView === 'myClaims'" x-transition>
                     <h2 class="text-2xl font-bold mb-4">My Prize Claims</h2>
                    <div class="overflow-x-auto bg-base-100 p-4 rounded-lg shadow">
                        <table class="table table-zebra w-full table-sm">
                            <thead><tr><th>Prize Claimed</th><th>Status</th><th>Reason (if rejected)</th><th>Timestamp</th></tr></thead>
                            <tbody>
                                <template x-if="myClaims.length === 0"><tr><td colspan="4" class="text-center italic py-4">You haven't made any claims yet.</td></tr></template>
                                <template x-for="claim in myClaims" :key="claim.claimId"> <tr>
                                        <td x-text="claim.prizeName"></td>
                                        <td>
                                            <span class="badge"
                                                  :class="{
                                                    'badge-success': claim.status === 'approved',
                                                    'badge-error': claim.status === 'rejected',
                                                    'badge-warning': claim.status === 'pending_admin_approval' || claim.status === 'pending_submission',
                                                    'badge-info': claim.status === 'pending_validation' || claim.status === 'pending'
                                                  }"
                                                  x-text="claim.status ? claim.status.replace(/_/g, ' ') : 'Unknown'">
                                            </span>
                                        </td>
                                        <td x-text="claim.reason || '---'"></td>
                                        <td x-text="claim.claimTimestamp ? new Date(claim.claimTimestamp.seconds * 1000).toLocaleString() : 'N/A'" class="text-xs"></td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div x-show="currentView === 'myPrizes'" x-transition> /* ... as before ... */ </div>

                <div x-show="gameMessage" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0 transform translate-y-2" x-transition:enter-end="opacity-100 transform translate-y-0" x-transition:leave="transition ease-in duration-300" x-transition:leave-start="opacity-100 transform translate-y-0" x-transition:leave-end="opacity-0 transform translate-y-2"
                     class="game-message-popup"
                     :class="{ /* ... */ }" x-text="gameMessage">
                </div>
            </main>
        </div>
        <div class="drawer-side z-[55]"> /* ... Sidebar as before ... */ </div>
    </div>

    <div class="bottom-nav-player-controls"> /* ... Buttons as before ... */ </div>
    <dialog id="claim_prize_modal" class="modal" x-ref="claimModal"> /* ... Modal as before ... */ </dialog>

    <script defer src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>

    <script>
      // =================================================================================
      // IMPORTANT: REPLACE WITH YOUR WEB APP'S FIREBASE CONFIGURATION
      // =================================================================================
     const firebaseConfig = {
    apiKey: "AIzaSyDeQ3YkvRLvPFnpTPz-aDyh9Yr6JNLqWF0",
    authDomain: "tambola-premium.firebaseapp.com",
    projectId: "tambola-premium",
    storageBucket: "tambola-premium.firebasestorage.app",
    messagingSenderId: "431036089573",
    appId: "1:431036089573:web:523500fb519d887535800c",
    measurementId: "G-EQHHTY8QKE"

      };
      // =================================================================================

      // Initialize Firebase
      let firebaseApp;
      if (!firebase.apps.length) {
          firebaseApp = firebase.initializeApp(firebaseConfig);
      } else {
          firebaseApp = firebase.app();
      }
      const auth = firebase.auth();
      const db = firebase.firestore(); // Firestore instance
      const functions = firebase.functions(); // Firebase Functions instance
    </script>

    <script>
    function playerGame() {
        return {
            // Core Player Info from localStorage (set by player_join.html)
            playerName: '',
            firebaseUserId: null, // Authenticated User ID
            firebaseUserEmail: '',
            roomId: '',

            // UI State
            adminName: '', // Fetched from Firestore room data
            isDrawerOpen: false,
            currentView: 'home',
            themes: ["light", "dark", "cupcake", /* ... other themes ... */ "winter"],
            notifications: [],

            // Game Data (synced from Firestore)
            tickets: [], // Array of ticket objects { id, numbers (2D array), marked (1D array of numbers) }
            calledNumbersHistory: [],
            latestCalledNumber: null,
            autoMarkNumbers: true,
            tempBoogieCells: [],

            // Room & Game Info from Firestore
            otherPlayersInRoom: [], // { id (UID), name, ticketCount }
            gameRules: [],    // { id, name, description, coinsPerPrize, maxPrizes, isActive }
            myClaims: [],     // { claimId, prizeName, prizeRuleId, status, reason, claimTimestamp, isOptimistic }
            myPrizes: [],     // { id (prize instance id), prizeName, coins }
            coinsWon: 0,

            // UI Interaction State
            waitingForTicketApproval: false, // This might change based on how new tickets are handled
            canClaimPrize: false,
            availablePrizesToClaim: [],
            selectedTicketIdForClaim: null,

            // Game Status & Messaging
            gameStatus: 'loading', // 'loading', 'idle', 'running', 'paused', 'stopped', 'error', 'disconnected'
            gameMessage: '',
            gameMessageType: 'info',
            gameMessageTimeout: null,

            // Firestore listeners unsubscribe functions
            roomListenerUnsubscribe: null,
            ticketsListenerUnsubscribe: null,
            claimsListenerUnsubscribe: null,

            get gameStatusMessage() { /* ... as before ... */ },

            init() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                this.setTheme(savedTheme, null, false);

                this.playerName = localStorage.getItem('playerName') || 'Player';
                this.roomId = localStorage.getItem('roomId') || null;
                this.firebaseUserId = localStorage.getItem('firebaseUserId') || null;
                this.firebaseUserEmail = localStorage.getItem('firebaseUserEmail') || null;

                if (!this.firebaseUserId || !this.roomId) {
                    this.showGameMessage("User session or Room ID missing. Please rejoin.", "error", null);
                    this.gameStatus = 'error';
                    // Redirect to join page if critical info is missing
                    setTimeout(() => { window.location.href = 'player_join.html'; }, 3000);
                    return;
                }
                this.showGameMessage("Loading game data...", "info", null);
                this.setupFirestoreListeners();
                this.fetchPlayerTickets(); // Fetch initial tickets

                this.$watch('tickets', (newTickets) => {
                    if (newTickets.length > 0 && !this.selectedTicketIdForClaim) {
                        this.selectedTicketIdForClaim = newTickets[0].id;
                    } else if (newTickets.length === 0) {
                        this.selectedTicketIdForClaim = null;
                    }
                     this.updateCanClaimPrizeStatus(); // Re-evaluate when tickets change
                });
                 this.$watch('gameRules', () => this.updateAvailablePrizes());
                 this.$watch('myClaims', () => this.updateAvailablePrizes());
                 this.$watch('myPrizes', () => this.updateAvailablePrizes());
            },

            setupFirestoreListeners() {
                if (!this.roomId) return;

                // 1. Listen to the Room document for game state
                const roomRef = db.collection('rooms').doc(this.roomId);
                this.roomListenerUnsubscribe = roomRef.onSnapshot((doc) => {
                    if (doc.exists) {
                        const roomData = doc.data();
                        this.gameStatus = roomData.gameStatus || 'idle';
                        this.calledNumbersHistory = roomData.currentNumbersCalled || [];
                        this.latestCalledNumber = roomData.currentLatestCalledNumber || null;
                        this.gameRules = roomData.rules?.filter(r => r.isActive) || []; // Only active rules for player
                        this.adminName = roomData.adminDisplayName || 'Admin';
                        // Update otherPlayersInRoom based on roomData.currentActivePlayers (map)
                        this.otherPlayersInRoom = roomData.currentActivePlayers ?
                            Object.entries(roomData.currentActivePlayers)
                                .filter(([uid, _]) => uid !== this.firebaseUserId) // Exclude self
                                .map(([uid, playerData]) => ({ id: uid, name: playerData.playerName, ticketCount: playerData.ticketCount || 0 }))
                            : [];

                        // Handle called numbers if autoMark is on
                        if (this.autoMarkNumbers && roomData.currentLatestCalledNumber &&
                            !this.calledNumbersHistory.slice(0,-1).includes(roomData.currentLatestCalledNumber) ) { // Process only new numbers for marking
                            this.markNumberOnTickets(roomData.currentLatestCalledNumber);
                        }
                        this.updateAvailablePrizes();
                        this.updateCanClaimPrizeStatus();
                        if(this.gameMessage === "Loading game data..."){ this.showGameMessage("Game data loaded!", "success", 2000); }

                        // Handle game start/stop notifications based on status change
                        // (More refined logic might be needed to prevent multiple notifications for same event)
                        if(this._previousGameStatus !== this.gameStatus) {
                            if(this.gameStatus === 'running' && this._previousGameStatus === 'idle'){
                                this.addNotification('Game Event', 'The game has started!', 'home');
                                this.myClaims = []; this.myPrizes = []; this.coinsWon = 0; // Reset for new game
                            } else if (this.gameStatus === 'stopped' && this._previousGameStatus !== 'stopped') {
                                const endMsg = "Game has ended.";
                                this.addNotification('Game Event', endMsg, 'home');
                            }
                        }
                        this._previousGameStatus = this.gameStatus;


                    } else {
                        this.showGameMessage(`Room ${this.roomId} not found or game not set up.`, "error", null);
                        this.gameStatus = 'error';
                    }
                }, (error) => {
                    console.error("Error listening to room updates:", error);
                    this.showGameMessage("Error syncing game data. Please refresh.", "error", null);
                    this.gameStatus = 'error';
                });

                // 2. Listen to player's claims from prizeClaimsAudit
                this.claimsListenerUnsubscribe = db.collection('prizeClaimsAudit')
                    .where('userId', '==', this.firebaseUserId)
                    .where('roomId', '==', this.roomId)
                    // .orderBy('claimTimestamp', 'desc') // Optional: order by time
                    .onSnapshot(snapshot => {
                        let newClaims = [];
                        let claimsUpdated = false;
                        snapshot.docChanges().forEach(change => {
                            const claimData = { id: change.doc.id, claimId: change.doc.id, ...change.doc.data() };
                            if (change.type === "added") {
                                newClaims.push(claimData);
                                claimsUpdated = true;
                                if(claimData.status === 'approved' && !this.myPrizes.some(p => p.id === 'prize_' + claimData.id)) {
                                     if (!this.myPrizes.some(p => p.id === 'prize_' + claimData.claimId)) {
                                        this.myPrizes.push({ id: 'prize_' + claimData.claimId, prizeName: claimData.prizeName, coins: claimData.coinsAwarded || 0 });
                                        this.coinsWon = parseFloat(((this.coinsWon || 0) + (claimData.coinsAwarded || 0)).toFixed(2));
                                     }
                                    this.addNotification('Prize Won!', `Your claim for ${claimData.prizeName} was APPROVED!`, 'myPrizes', claimData.claimId);
                                } else if (claimData.status === 'rejected') {
                                     this.addNotification('Claim Update', `Your claim for ${claimData.prizeName} was REJECTED.`, 'myClaims', claimData.claimId);
                                }
                            }
                            if (change.type === "modified") {
                                const index = this.myClaims.findIndex(c => c.claimId === claimData.claimId);
                                if (index !== -1) {
                                    this.myClaims.splice(index, 1, claimData);
                                } else {
                                    newClaims.push(claimData); // If modified but not found, add
                                }
                                claimsUpdated = true;
                                // Handle notifications for modified claims (e.g., status change)
                                if(claimData.status === 'approved' && !this.myPrizes.some(p => p.id === 'prize_' + claimData.id)) {
                                    if (!this.myPrizes.some(p => p.id === 'prize_' + claimData.claimId)) {
                                        this.myPrizes.push({ id: 'prize_' + claimData.claimId, prizeName: claimData.prizeName, coins: claimData.coinsAwarded || 0 });
                                        this.coinsWon = parseFloat(((this.coinsWon || 0) + (claimData.coinsAwarded || 0)).toFixed(2));
                                     }
                                    this.addNotification('Prize Won!', `Your claim for ${claimData.prizeName} was APPROVED!`, 'myPrizes', claimData.claimId);
                                } else if (claimData.status === 'rejected') {
                                     this.addNotification('Claim Update', `Your claim for ${claimData.prizeName} was REJECTED. Reason: ${claimData.reason || ''}`, 'myClaims', claimData.claimId);
                                }
                            }
                            if (change.type === "removed") {
                                this.myClaims = this.myClaims.filter(c => c.claimId !== claimData.claimId);
                                claimsUpdated = true;
                            }
                        });
                        if (newClaims.length > 0) {
                            this.myClaims = [...this.myClaims, ...newClaims].sort((a,b) => (b.claimTimestamp?.seconds || 0) - (a.claimTimestamp?.seconds || 0) );
                        }
                        if(claimsUpdated) this.updateAvailablePrizes();
                    }, error => {
                        console.error("Error listening to player claims:", error);
                        this.showGameMessage("Error syncing your prize claims.", "error");
                    });
            },

            fetchPlayerTickets() {
                if (!this.firebaseUserId || !this.roomId) return;
                this.showGameMessage("Fetching your tickets...", "info");
                db.collection('gameTickets')
                  .where('userId', '==', this.firebaseUserId)
                  .where('roomId', '==', this.roomId) // Add more filters if tickets are gameSession specific
                  .get()
                  .then(snapshot => {
                      const fetchedTickets = [];
                      snapshot.forEach(doc => {
                          fetchedTickets.push({ id: doc.id, ...doc.data(), marked: doc.data().marked || [] });
                      });
                      this.tickets = fetchedTickets;
                      if (this.tickets.length > 0 && !this.selectedTicketIdForClaim) {
                        this.selectedTicketIdForClaim = this.tickets[0].id;
                      }
                      this.updateCanClaimPrizeStatus();
                      this.showGameMessage(this.tickets.length > 0 ? "Tickets loaded." : "No tickets found for you in this room.", this.tickets.length > 0 ? "success" : "info");
                  })
                  .catch(error => {
                      console.error("Error fetching player tickets:", error);
                      this.showGameMessage("Could not load your tickets.", "error");
                  });
            },

            // Notification System Methods
            addNotification(type, message, targetView, relatedId = null) { /* ... as before ... */ },
            handleNotificationClick(notification) { /* ... as before ... */ },
            clearAllNotifications() { /* ... as before ... */ },

            // Game Actions & UI Logic (to be updated for Firestore/Cloud Functions)
            markNumberOnTickets(numberToMark) { /* ... as before ... */ },
            manualMarkNumber(ticketId, number) { /* ... as before ... */ },
            toggleAutoMarkBehavior() { /* ... as before ... */ },

            async requestNewTicket() {
                if (this.tickets.length >= 5) { this.showGameMessage("Max 5 tickets allowed.", "warning"); return; }
                if (this.gameStatus !== 'running') { this.showGameMessage("Game not running.", "warning"); return; }
                this.waitingForTicketApproval = true;
                this.showGameMessage("Requesting new ticket...", "info");
                try {
                    const requestTicketFunction = functions.httpsCallable('requestTicket'); // Ensure you have this CF
                    const result = await requestTicketFunction({ roomId: this.roomId, userId: this.firebaseUserId });
                    if (result.data.success) {
                        this.showGameMessage(result.data.message || "Ticket request sent to admin for approval.", "success");
                        // Server will notify admin, admin approval will trigger ticket assignment via Firestore.
                        // Client will get new ticket via its Firestore listener for gameTickets or player object.
                        // For now, we assume the admin needs to approve, and the listener will pick up the new ticket.
                    } else {
                        this.showGameMessage(result.data.message || "Failed to request ticket.", "error");
                    }
                } catch (error) {
                    console.error("Error requesting new ticket:", error);
                    this.showGameMessage("Error requesting ticket: " + error.message, "error");
                } finally {
                    this.waitingForTicketApproval = false;
                }
            },

            openClaimModal() { /* ... as before ... */ },
            updateAvailablePrizes() { /* ... as before ... */ },
            prizeAlreadyClaimedOrWon(prizeRuleId) { /* ... as before ... */ },

            async submitPrizeClaim(prizeRuleId) {
                if (!this.selectedTicketIdForClaim) { this.showGameMessage("Please select a ticket.", "warning"); return; }
                const rule = this.gameRules.find(r => r.id === prizeRuleId);
                if (rule) {
                    if (this.myClaims.some(c => c.prizeRuleId === prizeRuleId && (c.status === 'pending_admin_approval' || c.status === 'approved' || c.status === 'pending_submission'))) {
                        this.showGameMessage(`A claim for ${rule.name} is already submitted or processed.`, "info");
                        if (this.$refs.claimModal) this.$refs.claimModal.close();
                        return;
                    }

                    const clientTempClaimId = `client_${this.firebaseUserId}_${prizeRuleId}_${Date.now()}`;
                    this.myClaims.unshift({ // Add to start for immediate visibility
                        claimId: clientTempClaimId, prizeName: rule.name, prizeRuleId: prizeRuleId,
                        status: 'pending_submission', reason: '', isOptimistic: true,
                        claimTimestamp: { seconds: Math.floor(Date.now()/1000) } // Mock timestamp for sorting
                    });

                    this.showGameMessage(`Submitting claim for ${rule.name}...`, "info");
                    if (this.$refs.claimModal) this.$refs.claimModal.close();

                    try {
                        const submitClaimFunction = functions.httpsCallable('submitPrizeClaim'); // Ensure CF name
                        const result = await submitClaimFunction({
                            roomId: this.roomId,
                            userId: this.firebaseUserId,
                            playerName: this.playerName,
                            prizeRuleId: prizeRuleId,
                            prizeName: rule.name, // Send prize name for logging/display in claim doc
                            ticketId: this.selectedTicketIdForClaim,
                            clientTempClaimId: clientTempClaimId
                        });

                        if (result.data.success) {
                            // The PLAYER_CLAIM_SUBMITTED equivalent logic is handled by the Firestore listener on 'prizeClaimsAudit'
                            // We update the optimistic entry with the server's ID when the listener fires.
                            // this.showGameMessage(result.data.message || "Claim submitted for review!", "success");
                        } else {
                            this.showGameMessage(result.data.message || "Failed to submit claim.", "error");
                            this.myClaims = this.myClaims.filter(c => c.claimId !== clientTempClaimId); // Remove optimistic if failed
                        }
                    } catch (error) {
                        console.error("Error submitting prize claim:", error);
                        this.showGameMessage("Error submitting claim: " + error.message, "error");
                        this.myClaims = this.myClaims.filter(c => c.claimId !== clientTempClaimId); // Remove optimistic
                    }
                } else { this.showGameMessage("Selected prize rule not found.", "error"); }
            },

            updateCanClaimPrizeStatus() { /* ... as before ... */ },
            triggerConfetti() { /* ... as before ... */ },
            setTheme(themeName, event = null, closeDropdown = true) { /* ... as before ... */ },
            changeView(viewName) { /* ... as before ... */ },
            logout() {
                this.showGameMessage("Logging out...", "info", 1500);
                auth.signOut().then(() => {
                    // Clear listeners
                    if (this.roomListenerUnsubscribe) this.roomListenerUnsubscribe();
                    if (this.ticketsListenerUnsubscribe) this.ticketsListenerUnsubscribe();
                    if (this.claimsListenerUnsubscribe) this.claimsListenerUnsubscribe();

                    localStorage.removeItem('playerName');
                    localStorage.removeItem('roomId');
                    localStorage.removeItem('firebaseUserId');
                    localStorage.removeItem('firebaseUserEmail');
                    window.location.href = 'player_join.html';
                }).catch(error => {
                    console.error("Logout error:", error);
                    this.showGameMessage("Logout failed.", "error");
                });
            },
            showGameMessage(text, type = 'info', duration = 3000) { /* ... as before ... */ }
        }
    }
    </script>

    <div x-show="gameStatus !== 'connecting' && gameStatus !== 'error' && gameStatus !== 'disconnected' && gameStatus !== 'loading'"
        x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0 transform translate-y-2"
        x-transition:enter-end="opacity-100 transform translate-y-0" x-transition:leave="transition ease-in duration-200"
        x-transition:leave-start="opacity-100 transform translate-y-0" x-transition:leave-end="opacity-0 transform translate-y-2"
        class="fixed bottom-4 right-4 z-[60]">
        <span class="badge badge-lg badge-warning gap-2 shadow-md p-3">
            <i class="fas fa-coins"></i>
            <span x-text="coinsWon.toFixed(2)"></span>
        </span>
    </div>

</body>
</html>